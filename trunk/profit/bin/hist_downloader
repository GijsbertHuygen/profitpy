#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2007 Troy Melhase
# Distributed under the terms of the GNU General Public License v2
# Author: Troy Melhase <troy@gci.net>

import copy
import logging
import optparse
import signal
import sys
import time
import os

from cPickle import dump
from PyQt4.QtCore import QCoreApplication, QThread

from ib.opt import ibConnection
from ib.opt.message import registry

from profit.lib.core import Signals
from profit.session import Session, SessionBuilder, Ticker, Order, Contract, Series, DataCollection


class defaults:
    clientid = 1
    duration = 'forever'
    host = 'localhost'
    interval = 60
    nice = 19
    output = '%i%0.2i%0.2i.session' % time.localtime()[0:3]
    port = 7496
    start = 'immediate'
    stop = 'none'
    verbose = False


def check_duration(option, opt, value):
    try:
        return int(value)
    except (ValueError, ):
        if value == defaults.duration:
            return value
        else:
            raise optparse.OptionValueError(
                'option %s: invalid duration: %r' % (opt, value))


def check_hms(option, opt, value):
    if value.count(':') == 1:
        value += ':00'
    try:
        time.strptime(value, '%H:%M:%S')
    except (ValueError, ):
        if value in (defaults.start, defaults.stop):
            return value
        else:
            raise optparse.OptionValueError(
                'option %s: invalid time: %r' % (opt, value))
    else:
        return value


class LocalOption(optparse.Option):
    TYPES = optparse.Option.TYPES + ('duration', 'hms', )
    TYPE_CHECKER = copy.copy(optparse.Option.TYPE_CHECKER)
    TYPE_CHECKER['duration'] = check_duration
    TYPE_CHECKER['hms'] = check_hms


def options(args=None):
    if args is None:
        args = sys.argv[1:]

    defformat = ' [default:%default]'
    parser = optparse.OptionParser(version='%prog 0.2',
                                   conflict_handler='resolve',
                                   option_class=LocalOption)
    add_option = parser.add_option

    add_option('-d', '--duration', dest='duration',
                      help='collection duration in minutes' + defformat,
                      type='duration',
                      default=defaults.duration)

    add_option('-s', '--start', dest='start',
                      help='start time in 24-hour format HH:MM[:SS]' + defformat,
                      type='hms',
                      default=defaults.start)

    add_option('-t', '--stop', dest='stop',
                      help='stop time in 24-hour format HH:MM[:SS]' + defformat,
                      type='hms',
                      default=defaults.stop)

    add_option('-n', '--nice', dest='nice', metavar='NICE',
                      help='process niceness.' + defformat,
                      default=defaults.nice,
                      type='int')

    add_option('-p', '--port', dest='port', metavar='PORT',
                      help='remote port' + defformat,
                      default=defaults.port,
                      type='int')

    add_option('-h', '--hostname', dest='host', metavar='HOST',
                      help='remote host' + defformat,
                      default=defaults.host)

    add_option('-c', '--clientid', dest='clientid', metavar='CLIENTID',
                      help='client id' + defformat,
                      type='int',
                      default=defaults.clientid)

    add_option('-o', '--output', dest='output', metavar='OUTFILE',
                      default=defaults.output,
                      help='output filename' + defformat)

    add_option('-v', '--verbose', dest='verbose',
                      help='echo progress to stdout',
                      action='store_true',
                      default=defaults.verbose)
    add_option('-i', '--interval', dest='interval',
                     help='save interval in minutes' + defformat,
                     type='int',
                     default=defaults.interval)

    options, args = parser.parse_args()
    return options

class DownloadSessionBuilder(SessionBuilder):
    def __init__(self):
        #SessionBuilder.__init__(self)
        now = time.localtime()
        yesterday = (now[0], now[1], now[2]-1, 0, 0, 0, 0, 0, 0)
        self.default_histparams = {
            "endDateTime" :     time.strftime("%Y%m%d %H:%M:%S PST", yesterday),
            "durationStr" :     "6 D",
            "barSizeSetting" :  "1 min",    #5,          # 5 for 1min
            "whatToShow" :      "TRADES",   #"BID_ASK",  # "TRADES"
            "useRTH" :          1,          # 0 for not
            "formatDate" :      2,          # 2 for seconds since 1970/1/1
            }

    def accountData(self, *k):
        s = Series()
        #s.addIndex('EMA-25', EMA, s, 25)
        return s

    def strategy(self):
        return None

    def symbols(self):
        return {'AAPL':100, 'RMBS':101}

    def contract(self, symbol, secType='STK', exchange='SMART',
                 currency='USD'):
        contract = Contract()
        contract.m_symbol = symbol
        contract.m_secType = secType
        contract.m_exchange = exchange
        contract.m_currency = currency
        return contract

    def order(self):
        return Order()

    def ticker(self, tickerId):
        return Ticker()

    def series(self, tickerId, field):
        s = Series()
        return s

    def histparams(self, symbol, **kwds):
        "here we can check and change the params"
        self.default_histparams.update(kwds)
        return  self.default_histparams

from PyQt4.QtCore import QObject, QThread, SIGNAL

class HistDataCollection(DataCollection):

    fields = ["date", "open", "high", "low", "close", "volume", "count", "WAP",]

    def __init__(self, session, savedir='./histdata/'):
        DataCollection.__init__(self, session)
        self.iter = self.itersym()
        self.idsym = {}
        self.savedir = savedir 
        session.registerMeta(self)

    def on_session_HistoricalData(self, message):
        reqId = message.reqId
        try:
            tickerdata = self.data[reqId]
        except (KeyError, ):
            tickerdata = self.data[reqId] = \
                         self.session.builder.ticker(reqId)
            self.emit(Signals.createdTicker, reqId, tickerdata)

        for field in self.fields:
            try:
                seq = tickerdata.series[field]
            except (KeyError, ):
                seq = tickerdata.series[field] = \
                      self.session.builder.series(reqId, field) # this field is not used
                self.emit(Signals.createdSeries, reqId, field)
            seq.append(getattr(message, field))
            #print seq[-1],
            if field=="date" and seq[-1].startswith("finished"):
                print "reqId", reqId, "finished"
                print
                self.save(reqId)
                try:
                    self.iter.next()
                except StopIteration:
                    print "finished request for all symbols"
                    sys.exit(0)

    def itersym(self):
        sess = self.session
        for sym, tid in sess.builder.symbols().items():
            sess.requestHistData(tid, sym)
            self.idsym.setdefault(tid, sym)
            yield sym, tid

    def start(self):
        self.iter.next()

    def save(self, reqId):
        data = self.data[reqId]
        symbol = self.idsym[reqId]
        fpath = os.path.join(self.savedir, symbol[0])
        try:
            os.makedirs(fpath)
        except:
            pass
        fname = os.path.join(fpath, symbol)
        dump(data, open(fname, "wb"), protocol=-1)

                
class DownloadSession(Session):

    def __init__(self):
        Session.__init__(self, builder=DownloadSessionBuilder())
        self.histDataCollection = hdc = HistDataCollection(self)

    def connectTWS(self, hostName, portNo, clientId, enableLogging=False):
        self.connection = con = ibConnection(hostName, portNo, clientId)
        con.enableLogging(enableLogging)
        con.connect()
        con.registerAll(self.receiveMessage)
        con.register(self.on_nextValidId, 'NextValidId')
        con.register(self.on_error, 'Error')
        self.emit(Signals.connectedTWS)

    def on_error(self, message): 
        print message

    def requestHistData(self, id, symbol):
        connection = self.connection
        contract = self.builder.contract(symbol)
        histparams = self.builder.histparams(symbol)
        connection.reqHistoricalData(id, contract, **histparams)
        print "requested for", symbol, id, histparams


class CollectorThread(QThread):
    def __init__(self, stop, options, parent=None):
        QThread.__init__(self, parent)
        self.options = options
        self.stop = stop
        self.successful = False

    def run(self):
        logging.debug('Collector thread started.')
        last = time.time()
        stop = self.stop
        options = self.options
        interval = options.interval * 60

        self.session = session = DownloadSession()
        session = self.session
        self.connect(session, Signals.sessionStatus, logging.debug)
        session.filename = options.output
        session.connectTWS(
            options.host, options.port, options.clientid)
        if not session.isConnected:
            logging.error('Could not connect to %s:%s.',
                          options.host, options.port)
            logging.error('Aborting.')
            return
        session.requestAccount()
        session.histDataCollection.start()
        while True:
            now = time.time()
            if stop is not None:
                if stop < now:
                    break
            self.sleep(1)
            if last + interval < now:
                session.save()
                self.successful = True
                last = now
            QCoreApplication.processEvents()
        QCoreApplication.processEvents()
        logging.debug('Collector thread completed.')



class WaitingThread(QThread):
    def __init__(self, when, parent=None):
        QThread.__init__(self, parent)
        self.when = when

    def run(self):
        logging.debug('Wait thread started.')
        while True:
            now = time.time()
            if self.when < now:
                logging.debug('Wait thread completed.')
                return
            self.sleep(1)
            QCoreApplication.processEvents()


def main(options):
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)s %(levelname)s %(message)s')
    ymd = time.localtime()[0:3]
    start = options.start
    stop = options.stop
    duration = options.duration
    now = time.time()
    if start == defaults.start:
        startdelay = startat = 0
    else:
        hms = time.strptime(start, '%H:%M:%S')[3:]
        startat = time.mktime(ymd+hms)
        startdelay = startat - now
        if startdelay < 0:
            logging.warning('Start time in the past - adjusted +24 hours.')
            ymd = (ymd[0], ymd[1]+1, ymd[2])
            startat = time.mktime(ymd+hms)
            startdelay = startat - time.time()
    if stop == defaults.stop and duration == defaults.duration:
        stopat = None
    elif duration != defaults.duration:
        offset = startat if startat else now
        stopat = offset + (duration * 60)
    else:
        hms = time.strptime(stop, '%H:%M:%S')[3:]
        stopat = time.mktime(ymd+hms)
        if stopat < now:
            stopat += (60*60*24)
            logging.warning('Stop time in the past - adjusted +24 hours.')
    if startat:
        atdis = time.strftime('%H:%M:%S', time.localtime(startat))
        logging.debug('Collection will start at %s - delay %.2f seconds.',
                      atdis, startdelay)
    if stopat:
        logging.debug('Collection will stop at %s.', time.ctime(stopat))
    if startat:
        wait = WaitingThread(startat)
        wait.start()
        wait.wait()

    proc = CollectorThread(stopat, options)
    #proc.start()
    #proc.wait()
    proc.run()
    return proc.successful


if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    exit_codes = {False:255, True:0,}
    app = QCoreApplication(sys.argv)
    opts = options()
    res = main(opts)
    sys.exit(exit_codes.get(res, exit_codes[False]))
