#!/usr/bin/env python
# -*- coding: utf-8 -*-

# Copyright 2007 Troy Melhase
# Distributed under the terms of the GNU General Public License v2
# Author: Troy Melhase <troy@gci.net>

import copy
import logging
import optparse
import signal
import sys
import time

from PyQt4.QtCore import QCoreApplication, QThread

from profit.lib.core import Signals
from profit.session import Session


class defaults:
    clientid = 1
    duration = 'forever'
    host = 'localhost'
    interval = 60
    nice = 19
    output = '%i%0.2i%0.2i.session' % time.localtime()[0:3]
    port = 7496
    start = 'immediate'
    stop = 'none'
    verbose = False


def check_duration(option, opt, value):
    try:
        return int(value)
    except (ValueError, ):
        if value == defaults.duration:
            return value
        else:
            raise optparse.OptionValueError(
                'option %s: invalid duration: %r' % (opt, value))


def check_hms(option, opt, value):
    if value.count(':') == 1:
        value += ':00'
    try:
        time.strptime(value, '%H:%M:%S')
    except (ValueError, ):
        if value in (defaults.start, defaults.stop):
            return value
        else:
            raise optparse.OptionValueError(
                'option %s: invalid time: %r' % (opt, value))
    else:
        return value


class LocalOption(optparse.Option):
    TYPES = optparse.Option.TYPES + ('duration', 'hms', )
    TYPE_CHECKER = copy.copy(optparse.Option.TYPE_CHECKER)
    TYPE_CHECKER['duration'] = check_duration
    TYPE_CHECKER['hms'] = check_hms


def options(args=None):
    if args is None:
        args = sys.argv[1:]

    defformat = ' [default:%default]'
    parser = optparse.OptionParser(version='%prog 0.2',
                                   conflict_handler='resolve',
                                   option_class=LocalOption)
    add_option = parser.add_option

    add_option('-d', '--duration', dest='duration',
                      help='collection duration in minutes' + defformat,
                      type='duration',
                      default=defaults.duration)

    add_option('-s', '--start', dest='start',
                      help='start time in 24-hour format HH:MM[:SS]' + defformat,
                      type='hms',
                      default=defaults.start)

    add_option('-t', '--stop', dest='stop',
                      help='stop time in 24-hour format HH:MM[:SS]' + defformat,
                      type='hms',
                      default=defaults.stop)

    add_option('-n', '--nice', dest='nice', metavar='NICE',
                      help='process niceness.' + defformat,
                      default=defaults.nice,
                      type='int')

    add_option('-p', '--port', dest='port', metavar='PORT',
                      help='remote port' + defformat,
                      default=defaults.port,
                      type='int')

    add_option('-h', '--hostname', dest='host', metavar='HOST',
                      help='remote host' + defformat,
                      default=defaults.host)

    add_option('-c', '--clientid', dest='clientid', metavar='CLIENTID',
                      help='client id' + defformat,
                      type='int',
                      default=defaults.clientid)

    add_option('-o', '--output', dest='output', metavar='OUTFILE',
                      default=defaults.output,
                      help='output filename' + defformat)

    add_option('-v', '--verbose', dest='verbose',
                      help='echo progress to stdout',
                      action='store_true',
                      default=defaults.verbose)
    add_option('-i', '--interval', dest='interval',
                     help='save interval in minutes' + defformat,
                     type='int',
                     default=defaults.interval)

    options, args = parser.parse_args()
    return options


class CollectorThread(QThread):
    def __init__(self, stop, options, parent=None):
        QThread.__init__(self, parent)
        self.options = options
        self.stop = stop
        self.successful = False

    def run(self):
        logging.debug('Collector thread started.')
        last = time.time()
        stop = self.stop
        options = self.options
        interval = options.interval * 60
        self.session = session = Session()
        session.sessionFile = options.output
        session.connectTWS(
            options.host, options.port, options.clientid)
        if not session.isConnected:
            logging.error('Could not connect to %s:%s.',
                          options.host, options.port)
            logging.error('Aborting.')
            return
        session.requestAccount()
        session.requestOrders()
        session.requestTickers()
        self.connect(session, Signals.sessionStatus, logging.debug)
        while True:
            now = time.time()
            if stop is not None:
                if stop < now:
                    break
            self.sleep(1)
            if last + interval < now:
                session.save()
                self.successful = True
                last = now
            QCoreApplication.processEvents()
        session.save()
        while session.saveInProgress:
            self.sleep(1)
        QCoreApplication.processEvents()
        logging.debug('Collector thread completed.')


class WaitingThread(QThread):
    def __init__(self, when, parent=None):
        QThread.__init__(self, parent)
        self.when = when

    def run(self):
        logging.debug('Wait thread started.')
        while True:
            now = time.time()
            if self.when < now:
                logging.debug('Wait thread completed.')
                return
            self.sleep(1)
            QCoreApplication.processEvents()


def main(options):
    if options.verbose:
        logging.basicConfig(level=logging.DEBUG,
                            format='%(asctime)s %(levelname)s %(message)s')
    ymd = time.localtime()[0:3]
    start = options.start
    stop = options.stop
    duration = options.duration
    now = time.time()
    if start == defaults.start:
        startdelay = startat = 0
    else:
        hms = time.strptime(start, '%H:%M:%S')[3:]
        startat = time.mktime(ymd+hms)
        startdelay = startat - now
        if startdelay < 0:
            logging.warning('Start time in the past - adjusted +24 hours.')
            ymd = (ymd[0], ymd[1]+1, ymd[2])
            startat = time.mktime(ymd+hms)
            startdelay = startat - time.time()
    if stop == defaults.stop and duration == defaults.duration:
        stopat = None
    elif duration != defaults.duration:
        offset = startat if startat else now
        stopat = offset + (duration * 60)
    else:
        hms = time.strptime(stop, '%H:%M:%S')[3:]
        stopat = time.mktime(ymd+hms)
        if stopat < now:
            stopat += (60*60*24)
            logging.warning('Stop time in the past - adjusted +24 hours.')
    if startat:
        atdis = time.strftime('%H:%M:%S', time.localtime(startat))
        logging.debug('Collection will start at %s - delay %.2f seconds.',
                      atdis, startdelay)
    if stopat:
        logging.debug('Collection will stop at %s.', time.ctime(stopat))
    if startat:
        wait = WaitingThread(startat)
        wait.start()
        wait.wait()
    proc = CollectorThread(stopat, options)
    proc.start()
    proc.wait()
    return proc.successful


if __name__ == '__main__':
    signal.signal(signal.SIGINT, signal.SIG_DFL)
    exit_codes = {False:255, True:0,}
    app = QCoreApplication(sys.argv)
    opts = options()
    res = main(opts)
    sys.exit(exit_codes.get(res, exit_codes[False]))
